# Stacking模型融合

* 1.介绍一下stacking的原理等
* 2.机器学习算法进行stacking很常见，像mlxtend等库对stacking算法封装还不错
* 3.简单实现一下神经网络的stacking算法

#### 最经典的一张图:
* ![](https://github.com/dyngq/notebooks/blob/master/images/20190427-model-fusion-algorithm/stacking-1.jpg)
* 但是可以不从这个图开始理解，重要的是总体的思想，这个图是一个表较复杂，比较不容易过拟合的一种复杂实现。
* 对于stacking的理解可以由浅入深，先从整体上把握，再针对不同的情境复杂优化。

## 总体概述：
* stacking原则上可以分成若干层级，但层数多不一定效果越好，一般采用两层结构。
* 因此，我们可以把stacking过程看作是两个级别，级别0和级别1。
    * 0级:  第0级数据是训练数据集的输入，0级模型学习如何从这些数据中进行预测。可以是随机森林，SVM等等多个0级模型，也可以用于只有一个0级模型的情况。
    * 1级:  第1级数据以第0级模型的输出作为输入，第1级模型学习从该0级数据进行预测。一般采用逻辑回归等简单模型。

* 总体思想就是分两级模型，实例化0级模型，0级模型正常训练，记录0级模型对训练集的预测，把0级模型的预测作为的x，把训练集原来真正的label作为y，输入到下一级，也就是第1 级。第1级模型通过对所有第0级模型的输出进行学习，学习出最好的0级模型融合方法，输出最终的label。

* 原理如图所示：
* ![](https://github.com/dyngq/notebooks/blob/master/images/20190427-model-fusion-algorithm/stacking-2.jpg)
* ![](https://github.com/dyngq/notebooks/blob/master/images/20190427-model-fusion-algorithm/stacking-3.jpg)


## 下面是网上最常见的stacking方法解释(也就是文章已开始的图片所描述的)       (深度学习的应用在下一部分)
#### 一种更为复杂的方法是使用k-fold交叉验证来开发元学习机模型的训练数据集，也就是对应一开始的那张图片。每个0级模型都使用k-fold交叉验证(甚至为了达到最大效果使用留一法交叉验证)进行训练;然后模型被丢弃，但是预测被保留。这意味着对于每个模型，都有一个模型版本所做的预测，而这个版本的模型并没有针对这些例子进行训练，例如，有一些在预留的例子。

### 下面是比较好最普遍的解释：
* ![](https://github.com/dyngq/notebooks/blob/master/images/20190427-model-fusion-algorithm/stacking-1.jpg)

对于每一轮的 5-fold，Model 1都要做满5次的训练和预测。
Titanic 栗子：
Train Data有890行。(请对应图中的上层部分）
每1次的fold，都会生成 713行 小train， 178行 小test。我们用Model 1来训练 713行的小train，然后预测 178行 小test。预测的结果是长度为 178 的预测值。
这样的动作走5次！ 长度为178 的预测值 X 5 = 890 预测值，刚好和Train data长度吻合。这个890预测值是Model 1产生的，我们先存着，因为，一会让它将是第二层模型的训练来源。
重点：这一步产生的预测值我们可以转成 890 X 1 （890 行，1列），记作 P1 (大写P)

接着说 Test Data 有 418 行。(请对应图中的下层部分，对对对，绿绿的那些框框）

每1次的fold，713行 小train训练出来的Model 1要去预测我们全部的Test Data（全部！因为Test Data没有加入5-fold，所以每次都是全部！）。此时，Model 1的预测结果是长度为418的预测值。

这样的动作走5次！我们可以得到一个 5 X 418 的预测值矩阵。然后我们根据行来就平均值，最后得到一个 1 X 418 的平均预测值。

重点：这一步产生的预测值我们可以转成 418 X 1 （418行，1列），记作 p1 (小写p)

走到这里，你的第一层的Model 1完成了它的使命。

第一层还会有其他Model的，比如Model 2，同样的走一遍， 我们有可以得到  890 X 1  (P2) 和  418 X 1 (p2) 列预测值。

这样吧，假设你第一层有3个模型，这样你就会得到：

来自5-fold的预测值矩阵 890 X 3，（P1，P2， P3）  和 来自Test Data预测值矩阵 418 X 3， （p1, p2, p3）。

-----------------------------------------

到第二层了..................

来自5-fold的预测值矩阵 890 X 3 作为你的Train Data，训练第二层的模型
来自Test Data预测值矩阵 418 X 3 就是你的Test Data，用训练好的模型来预测他们吧。

---------------------------------------

最后 ，放出一张Python的Code，在网上为数不多的stacking内容里， 这个几行的code你也早就看过了吧，我之前一直卡在这里，现在加上一点点注解，希望对你有帮助：