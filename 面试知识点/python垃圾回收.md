> **引用计数器** 为主
>
> **标记清除** 和 **分代回收** 为辅
>
> +**缓存机制**

## 0x01 引用计数器

### 1-1 循环双向链表（C语言）refchain

* python的创建的任何对象都会放在**refchain**中。

### 1-2 类型封装结构体

* ![image-20210323151800681](D:\Pictures\markdown.img\image-20210323151800681.png)
* ![image-20210323152557442](D:\Pictures\markdown.img\image-20210323152557442.png)

### 1-3 引用计数器

* 当python程序运行时，会根据数据类型的不同找到其对应的结构体，根据结构体中的字段来进行创建相关的数据，然后将对象添加到refchain双线链表中。在C源码中有两个关键的结构体: PyObject、 PyVar0bject。

* 每个对象中有ob_refcnt就是引用计数器,值默认为1，当有其他变量引用对象时，引用计数器就会发生变化。

  * 引用 

    ```Python
    a = 123123 # 创建对象，引用计数器默认为1
    b = 1 # 对象的引用计数器+1
    ```

  * 删除引用

    ```python
    del b # 删除b变量，对应对象的引用计数器 -1
    del a # 删除a变量，对应对象的引用计数器 -1， = 0
    ```

  * 当引用计数器为0时，这个对象就是垃圾，需要垃圾回收

  * **回收**：

    1. **对象从refchain中删除**
    2. **对象销毁，内存归还**

## 0x02 标记清除 (2个链表)

### 2-1 循环引用，交叉感染

* v1，v2对象开始为1，引用加1，删除减1，最后一直为1，无法清除![image-20210323153820994](D:\Pictures\markdown.img\image-20210323153820994.png)

### 2-2 标记清除

1. **目的**:为了解决引用计数器循环引用的不足。
2. **实现**:在python的底层再维护一个链表，链表中专门]放那些可能存在循环引用的对象(list/tuple/dict/set) 。

* 在Python内部某种情况下**触发**，会去**扫描**可能存在循环引用的链表中的**每个元素**，**检查**是否有**循环引用**，如果有则让双方的**引用计数器`-1`** ;如果是`0`则垃圾回收。

## 0x03 分代回收 (3个链表)

> 1. 扫描时机，什么时候扫描？
> 2. 扫描代价大，耗时久

将可能存在循环应用的对象维护成3个链表: 

* 0代: 0代中对象个数达到700个扫描一次。垃圾回收，不是垃圾升级1代。
* 1代: 0代扫描10次，则1代扫描一次。垃圾回收，不是垃圾升级2代。
* 2代: 1代扫描10次，则2代扫描一次。

## 0x04 小结

![image-20210323194745324](D:\Pictures\markdown.img\image-20210323194745324.png)

## 0x05 Python缓存

### 5-1 池

 为了避免重复创建和销毁--些常见对象，维护池。

```python
#启动解释器时，python内部帮我们创处: -5、-4、..... 256
v1 = 7 #内部不会开辟内存，直接去池中获取
v2 = 9 #内部不会开辟内存，直接去池中获取
v3 = 9 #内部不会开辟内存，直接去池中获取
print(id(v2),id(v3))
```

### 5-2 free_list

当一个对象的引用计数器为0时，按理说应该回收，内部不会直接回收，而是将对象添加到free. list 链表中当缓存。以后再去创建对象时，不再重新开辟内存，而是直接使用free_list.

```python
v1 = 3.14  #开辟内存，内部存储结构体中定义那几个值，并存到refchain中。
de1 v1     # refchain中移除， 将对象添加到free_list中。
v9 = 999.99 #不会重新开辟内存，去free. _1ist中获取对象， 对象内部数据初始化，再放到refchain中。
```